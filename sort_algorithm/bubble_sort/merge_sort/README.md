<h1>병합정렬</h1>
<p>1. 병합 정렬은 배열을 앞부분과 뒷부분의 두 그룹으로 나누어 각각 정렬한 후 병합하는 작업을 반복하는 알고리즘입니다.</br>
  2. 안정정렬에 속하며, 분활 정복 알고리즘에 속하다.</p>

<h3>병합 정렬 알고리즘의 수행 순서</h3>
  <ol>
    <li>배열의 앞부분을 병합 정렬로 정렬합니다.</li>
    <li>배열의 뒷부분을 병합 정렬 합니다.</li>
    <li>배열의 앞부분과 뒷부분을 병합합니다.</li>
  </ol>
<h3>병합 정렬 알고리즘의 특징</h3>
 <p>
  <ul>
    <li>장점</li>
    - 안정적인 정렬 알고리즘</br>
    - 데이터 분포에 영향을 덜 받는다. 입력데이터가 무엇이든 간에 정렬 되는 시간은 동일하다.</br>
    <li>단점</li>
    - 알고리즘을 배열로 구현하면 임시 배열이 필요하다.</br>
    - record들의 크기가 큰 경우에는 이동횟수가 많으므로 매우 큰 시간적 낭비가 초래된다.</br>
  </ul>
 </p>
 
<h3>병합정렬의 시간복잡도</h3>
  <p>배열병합의 시간복잡도는 O(n)이다. 데이터 원소수가 n일때 병합 정렬의 단계는 logn만큼 필요하므로 전체 시간 복잡도는 O(nlogn)입니다. 병합 정렬 알고리즘은 서로 떨어져 있는 
  원소를 교환하는 것이 아니므로 안정적이다.</p>
  <ul>
    <li>Best : NlogN</li>
    <li>ave : NlogN</li>
    <li>worst : NlogN</li>
  </ul>
  
 <h3>heapq를 이용한 merge_sort</h3>
 <ul>
  <li>sorted()</li>
  <pre>
    a = [1,2,3,4,5]
    b = [5,7,5,6,8]
    c = list(sorted(a + b))
    -> a 와 b를 연결하여 오름차순으로 정렬한 것을 list로 변한하여 c에 저장
  </pre>
  <p>a와 b가 정렬을 마친 상태가 아니어도 적용할 수 있다는 장점이 있지만, 속도가 빠르지 않다는 단점이 있다. </p>
  <li>heapq.merge</li>
  <p>-> 빠르게 병합하려면 heapq모듈에 merge함수 사용</p>
  <pre>
    import heapq
    a = [2,4,6,9,12,13]
    b = [1,2,3,4,7,13,32]
    c = list(heapq.merge(a,b))
  </pre>
</ul>
